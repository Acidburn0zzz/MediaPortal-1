#region Copyright (C) 2005-2011 Team MediaPortal

// Copyright (C) 2005-2011 Team MediaPortal
// http://www.team-mediaportal.com
// 
// MediaPortal is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// MediaPortal is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with MediaPortal. If not, see <http://www.gnu.org/licenses/>.

#endregion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Serialization;
using Gentle.Framework;
using RuleBasedScheduler;
using TvLibrary.Interfaces;
using TvLibrary.Log;

namespace TvDatabase
{
  /// <summary>
  /// Instances of this class represent the properties and methods of a row in the table <b>Schedule</b>.
  /// </summary>
  [TableName("RuleBasedSchedule")]
  public class RuleBasedSchedule : Persistent
  {
    private ScheduleConditionList _scheduleConditions;
    public static DateTime MinSchedule = new DateTime(2000, 1, 1);
    public static readonly int HighestPriority = Int32.MaxValue;
    //public static readonly int LowestPriority;

    private void DeserializeRules()
    {
      try
      {
        _scheduleConditions = ScheduleConditionHelper.Deserialize<ScheduleConditionList>(rules);      
      }
      catch (Exception ex)
      {
        Log.Error("RuleBasedSchedule could not Deserialize Rules");
      }      
    }

    private void SerializeRules()
    {
      rules = ScheduleConditionHelper.Serialize<ScheduleConditionList>(_scheduleConditions);
    }

    #region Members

    private bool isChanged;
    [TableColumn("id_RuleBasedSchedule", NotNull = true), PrimaryKey(AutoGenerated = true)] private int idRuleBasedSchedule;
    [TableColumn("schedulename", NotNull = true)] private string scheduleName;    
    [TableColumn("maxAirings", NotNull = true)] private int maxAirings;
    [TableColumn("priority", NotNull = true)] private int priority;
    [TableColumn("directory", NotNull = true)] private string directory;
    [TableColumn("quality", NotNull = true)] private int quality;
    [TableColumn("keepMethod", NotNull = true)] private int keepMethod;
    [TableColumn("keepDate", NotNull = true)] private DateTime keepDate;
    [TableColumn("preRecordInterval", NotNull = true)] private int preRecordInterval;
    [TableColumn("postRecordInterval", NotNull = true)] private int postRecordInterval;            
    [TableColumn("rules", NotNull = true)] private string rules;

    #endregion

    #region Constructors

    public RuleBasedSchedule(string scheduleName)
    {
      isChanged = true;
      ScheduleName = scheduleName;
      Directory = "";
      KeepDate = MinSchedule;
      KeepMethod = (int)KeepMethodType.UntilSpaceNeeded;
      MaxAirings = Int32.MaxValue;
      PostRecordInterval = 0;
      PreRecordInterval = 0;
      Priority = 0;
      quality = 0;
      BitRateMode = VIDEOENCODER_BITRATE_MODE.NotSet;
      QualityType = QualityType.NotSet;
    }

    /// <summary> 
    /// Create a new object by specifying all fields (except the auto-generated primary key field). 
    /// </summary> 
    public RuleBasedSchedule(string scheduleName,
                    int maxAirings, int priority, string directory, int quality, int keepMethod, DateTime keepDate,
                    int preRecordInterval, int postRecordInterval)
    {
      isChanged = true;
      this.scheduleName = scheduleName;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;
    }

    /// <summary> 
    /// Create a new schedule from an existing one (except the auto-generated primary key field). 
    /// </summary> 
    public RuleBasedSchedule(RuleBasedSchedule schedule)
    {
      isChanged = true;
      scheduleName = schedule.scheduleName;
      maxAirings = schedule.maxAirings;
      priority = schedule.priority;
      directory = schedule.directory;
      quality = schedule.quality;
      keepMethod = schedule.keepMethod;
      keepDate = schedule.keepDate;
      preRecordInterval = schedule.preRecordInterval;
      postRecordInterval = schedule.postRecordInterval;      
    }

    /// <summary> 
    /// Create an object from an existing row of data. This will be used by Gentle to 
    /// construct objects from retrieved rows. 
    /// </summary> 
    public RuleBasedSchedule (int idRuleBasedSchedule, string scheduleName, int maxAirings, int priority, string directory, int quality, int keepMethod,
                    DateTime keepDate, int preRecordInterval, int postRecordInterval)
    {
      this.idRuleBasedSchedule = idRuleBasedSchedule;
      this.scheduleName = scheduleName;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;      
    }

    #endregion

    #region Public Properties

    /// <summary>
    /// Property relating to database column id_Schedule
    /// </summary>
    public ScheduleConditionList Rules
    {
      get
      {
        if (_scheduleConditions == null)
        {
          DeserializeRules();
        }
        return _scheduleConditions;        
      }
      set
      {
        _scheduleConditions = value;        
      }
    }

    /// <summary>
    /// Indicates whether the entity is changed and requires saving or not.
    /// </summary>
    public bool IsChanged
    {
      get { return isChanged; }
    }

    /// <summary>
    /// Property relating to database column id_Schedule
    /// </summary>
    public int IDRuleBasedSchedule
    {
      get { return idRuleBasedSchedule; }
    }   

    

    /// <summary>
    /// Property relating to database column programName
    /// </summary>
    public string ScheduleName
    {
      get { return scheduleName; }
      set
      {
        isChanged |= scheduleName != value;
        scheduleName = value;
      }
    }


    /// <summary>
    /// Property relating to database column maxAirings
    /// </summary>
    public int MaxAirings
    {
      get { return maxAirings; }
      set
      {
        isChanged |= maxAirings != value;
        maxAirings = value;
      }
    }

    /// <summary>
    /// Property relating to database column priority
    /// </summary>
    public int Priority
    {
      get { return priority; }
      set
      {
        isChanged |= priority != value;
        priority = value;
      }
    }

    /// <summary>
    /// Property relating to database column directory
    /// </summary>
    public string Directory
    {
      get { return directory; }
      set
      {
        isChanged |= directory != value;
        directory = value;
      }
    }

    /// <summary>
    /// Property relating to database column quality
    /// </summary>
    public int Quality
    {
      get { return quality; }
      set
      {
        isChanged |= quality != value;
        quality = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepMethod
    /// </summary>
    public int KeepMethod
    {
      get { return keepMethod; }
      set
      {
        isChanged |= keepMethod != value;
        keepMethod = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepDate
    /// </summary>
    public DateTime KeepDate
    {
      get { return keepDate; }
      set
      {
        isChanged |= keepDate != value;
        keepDate = value;
      }
    }

    /// <summary>
    /// Property relating to database column preRecordInterval
    /// </summary>
    public int PreRecordInterval
    {
      get { return preRecordInterval; }
      set
      {
        isChanged |= preRecordInterval != value;
        preRecordInterval = value;
      }
    }

    /// <summary>
    /// Property relating to database column postRecordInterval
    /// </summary>
    public int PostRecordInterval
    {
      get { return postRecordInterval; }
      set
      {
        isChanged |= postRecordInterval != value;
        postRecordInterval = value;
      }
    }
    

    #endregion

    #region Storage and Retrieval

    /// <summary>
    /// Static method to retrieve all instances that are stored in the database in one call
    /// </summary>
    public static IList<RuleBasedSchedule> ListAll()
    {
      return Broker.RetrieveList<RuleBasedSchedule>();
    }

    public static IList<RuleBasedSchedule> FindOrphanedOnceSchedules()
    {
      //todo impl
      IList<RuleBasedSchedule> newList = new List<RuleBasedSchedule>();
      return newList;
    }

    public static RuleBasedSchedule FindNoEPGSchedule(Channel channel)
    {
      int idChannel = channel.IdChannel;

      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "idParentSchedule", -1);
      sb.AddConstraint(Operator.Equals, "series", false);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<RuleBasedSchedule> getList = ObjectFactory.GetCollection<RuleBasedSchedule>(stmt.Execute());
      if (getList.Count != 0)
      {        
        return getList[0];
      }
      return null;
    }

    public static bool IsScheduleRecording(int id, Program prg)
    { // this is not about the schedule at all...  is asking whether program is recording right now
      bool isScheduleRecording = false;
    
      //todo implement

      return isScheduleRecording;
    }

    public static bool IsScheduleRecording(int id)
    {
      bool isScheduleRecording = false;

      //todo implement

      return isScheduleRecording;
    }

    /// <summary>
    /// Retrieves an entity given it's id.
    /// </summary>
    public static RuleBasedSchedule Retrieve(int id)
    {
      // Return null if id is smaller than seed and/or increment for autokey
      if (id < 1)
      {
        return null;
      }
      Key key = new Key(typeof (Schedule), true, "id_Schedule", id);
      return Broker.TryRetrieveInstance<RuleBasedSchedule>(key);
    }

    /// <summary>
    /// Retrieves an entity given it's id, using Gentle.Framework.Key class.
    /// This allows retrieval based on multi-column keys.
    /// </summary>
    public static RuleBasedSchedule Retrieve(Key key)
    {
      return Broker.TryRetrieveInstance<RuleBasedSchedule>(key);
    }

    public static void SynchProgramStatesForAll()
    {
      Log.Info("schedule.SynchProgramStatesForAll");
      IList<RuleBasedSchedule> allSchedules = RuleBasedSchedule.ListAll();

      if (allSchedules != null && allSchedules.Count > 0)
      {
        foreach (RuleBasedSchedule schedule in allSchedules)
        {
          Schedule.SynchProgramStates(schedule.idRuleBasedSchedule);
        }
      }
    }

    public static void ResetProgramStates(int idSchedule)
    {
      RuleBasedSchedule schedule = RuleBasedSchedule.Retrieve(idSchedule);
      if (schedule == null)
      {
        return;
      }

      var progs = GetProgramsForSchedule(schedule);
      foreach (var prog in progs)
      {
        Program.ResetPendingState(prog.IdProgram);
        prog.Persist();
      }
    }

    public static void SynchProgramStates(int idSchedule)
    {
      RuleBasedSchedule schedule = RuleBasedSchedule.Retrieve(idSchedule);
      if (schedule == null)
      {
        return;
      }

      var progs = GetProgramsForSchedule(schedule);
      foreach (var prog in progs)
      {
        if(schedule.IsSerieIsCanceled(schedule.GetSchedStartTimeForProg(prog)))
        {
          // program has been cancelled so reset any pending recording flags
          Program.ResetPendingState(prog.IdProgram);
          prog.Persist();
        }
        else
        {
          bool isPartialRecording = RuleBasedSchedule.IsPartialRecording(schedule, prog);
          if (schedule.Rules.Count() == 0)
          {
            // is one off recording that is still active so set pending flags accordingly
            prog.IsRecordingOncePending = true;
            prog.IsRecordingSeriesPending = false;
            prog.IsPartialRecordingSeriesPending = false;
            prog.Persist();
          }
          else if (isPartialRecording)
          {
            // is part of a series recording but is a time based schedule and program times do not
            // match up with schedule times so flag as partial recording
            prog.IsRecordingOncePending = false;
            prog.IsRecordingSeriesPending = false;
            prog.IsPartialRecordingSeriesPending = true;
            prog.Persist();
          }
          else
          {
            // is part of a series recording but is not a partial recording
            prog.IsRecordingOncePending = false;
            prog.IsRecordingSeriesPending = true;
            prog.IsPartialRecordingSeriesPending = false;
            prog.Persist();
          }
        }
      }
    }

    public static IList<Program> GetProgramsForSchedule(RuleBasedSchedule schedule)
    {
      IList<Program> progs = null;

      //todo implement

      return progs;
    }

    public static bool IsPartialRecording(RuleBasedSchedule schedule, Program prg)
    {
      if (schedule.Rules.Count()> 0)
      {
        return false;
      }

      DateTime schStart;
      DateTime schEnd;

      if (schedule.GetAdjustedScheduleTimeRange(prg, out schStart, out schEnd))
      {
        return (prg.StartTime < schStart || prg.EndTime > schEnd);
      }
      else
      {
        Log.Info(
          "IsPartialRecording: program ({0} {1} - {2} is not (at least partially) included in the schedule {3:hh:mm} - {4:hh:mm}",
          prg.Title, prg.StartTime, prg.EndTime);
        return false;
      }
    }


    /// <summary>
    /// Persists the entity if it was never persisted or was changed.
    /// </summary>
    public override void Persist()
    {
      if (IsChanged || !IsPersisted)
      {
        try
        {          
          SerializeRules();
          base.Persist();
          //WE HAVE TO HANDLE CANCELLED SCHEDULES AND SKIP THOSE - WE DO NOT WANT TO MARK CANCLLED AS recpending.
          //SynchProgramStates(this.idRuleBasedSchedule);
        }
        catch (Exception ex)
        {
          Log.Error("Exception in Schedule.Persist() with Message {0}", ex.Message);
          return;
        }
        isChanged = false;
      }
    }    

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>    
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>    
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Once' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveOnce(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    #endregion

    #region Relations

    /// <summary>
    /// Get a list of CanceledSchedule referring to the current entity.
    /// </summary>
    public IList<CanceledSchedule> ReferringCanceledSchedule()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (CanceledSchedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idRuleBasedSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<CanceledSchedule>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ReferringConflicts()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idRuleBasedSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ConflictingSchedules()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idConflictingSchedule", idRuleBasedSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }  

   
    #endregion

    public bool IsSerieIsCanceled(DateTime startTimeParam)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam)
        {
          return true;
        }
      }
      return false;
    }

    public bool IsSerieIsCanceled(DateTime startTimeParam, int idChannel)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam && schedule.IdChannel == idChannel)
        {
          return true;
        }
      }
      return false;
    }

    public void UnCancelSerie()
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        schedule.Remove();
        Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                            schedule.IdChannel,
                                            schedule.ReferencedSchedule().ProgramName);
      }
      return;
    }

    public void UnCancelSerie(DateTime startTimeParam, int idChannel)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam && schedule.IdChannel == idChannel)
        {
          schedule.Remove();
          Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                              schedule.IdChannel,
                                              schedule.ReferencedSchedule().ProgramName);
        }
      }
      return;
    }

    /// <summary>
    /// Checks if the recording should record the specified tvprogram
    /// </summary>
    /// <param name="program">TVProgram to check</param>
    /// <returns>true if the specified tvprogram should be recorded</returns>
    /// <returns>filterCanceledRecordings (true/false)
    /// if true then  we'll return false if recording has been canceled for this program</returns>
    /// if false then we'll return true if recording has been not for this program</returns>
    public bool IsRecordingProgram(Program program, bool filterCanceledRecordings)
    {
      if (program == null)
      {
        return false;
      }
      //TODO implement
      return false;
    }
  
    /// <summary>
    /// This takes a program as an argument and overlaps it with the schedule start time
    /// The date element of the start time of a schedule is the date of the first episode
    /// but for cancelling episodes of a time based schedule the cancellation row in the database 
    /// needs the start time of the episode rather than a program.
    /// eg. if a schedule is setup 20:00 until 21:00 every day starting on 1st April and on 3rd April the 
    /// there is no program for this period and user selects a program at 20:30 to 21:30 and asks to 
    /// cancel the epsiode, we need to return 3rd April 20:00 
    /// 
    /// If program does not fall within schedule (eg. you call with a program that starts 21:30)
    /// this will return that start time of the program
    /// </summary>
    /// <param name="prog">The program to check</param>
    /// <returns>The start time of the episode within a schedule that overlaps with program</returns>
    public DateTime GetSchedStartTimeForProg(Program prog)
    {
      DateTime dtSchedStart;
      DateTime dtSchedEnd;
      if (GetAdjustedScheduleTimeRange(prog, out dtSchedStart, out dtSchedEnd))
      {
        return dtSchedStart;
      }
      return prog.StartTime;
    }

    /// <summary>
    /// Try to offset this schedule's time range by an integral number
    /// of days so that it overlaps the <paramref name="program"/> time range.
    /// </summary>
    /// <param name="program">The program to use for adjusting the timerange</param>
    /// <param name="scheduleStart">The adjusted start date/time</param>
    /// <param name="scheduleEnd">The adjusted end date/time</param>
    /// <returns>True if a suitable adjustment was found</returns>
    private bool GetAdjustedScheduleTimeRange(Program program, out DateTime scheduleStart, out DateTime scheduleEnd)
    {
      //todo implement
      scheduleStart = new DateTime();
      scheduleEnd = new DateTime();
      return true;
    }

    public bool DoesUseEpisodeManagement
    {
      get
      {
        if (MaxAirings == Int32.MaxValue)
        {
          return false;
        }
        if (MaxAirings < 1)
        {
          return false;
        }
        return true;
      }
    }

    /// <summary>
    /// Checks whether this recording is finished and can be deleted
    /// 
    /// </summary>
    /// <returns>true:Recording is finished can be deleted
    ///          false:Recording is not done yet, or needs to be done multiple times
    /// </returns>
    public bool IsDone()
    {
      //TODO implement      
      return false;
    }

    public void Delete()
    {
      int id = this.idRuleBasedSchedule;
      IList<Conflict> list = ReferringConflicts();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      list = ConflictingSchedules();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      IList<CanceledSchedule> listCanceledSchedule = ReferringCanceledSchedule();
      foreach (CanceledSchedule schedule in listCanceledSchedule)
      {
        schedule.Remove();
      }

      // does the schedule still exist ?
      // if yes then remove it, if no leave it.
      RuleBasedSchedule schedExists = Retrieve(idRuleBasedSchedule);
      if (schedExists != null)
      {
        Schedule.ResetProgramStates(id);
        Remove();
      }
    }
   

    public RuleBasedSchedule Clone()
    {
      RuleBasedSchedule schedule = new RuleBasedSchedule(ScheduleName,
                                       MaxAirings, Priority,
                                       Directory, Quality, KeepMethod, KeepDate, PreRecordInterval, PostRecordInterval);

      
      schedule.idRuleBasedSchedule = idRuleBasedSchedule;
      schedule.isChanged = false;
      return schedule;
    }

    public bool IsOverlapping(RuleBasedSchedule schedule)
    {
      //todo implement
      return false;
    }

    /// <summary>
    /// checks if 2 schedules have a common Transponder
    /// depending on tuningdetails of their respective channels
    /// </summary>
    /// <param name="schedule"></param>
    /// <returns>True if a common transponder exists</returns>
    public bool isSameTransponder(RuleBasedSchedule schedule)
    {
      //todo impl
      return false;
    }

    public QualityType QualityType
    {
      get { return (QualityType)(quality / 10); }
      set
      {
        int type = ((int)value);
        quality = (type * 10) + (quality % 10);
      }
    }

    public VIDEOENCODER_BITRATE_MODE BitRateMode
    {
      get { return (VIDEOENCODER_BITRATE_MODE)(quality % 10); }
      set
      {
        int mode = ((int)value);
        quality = mode + ((quality / 10) * 10);
      }
    }

    public override string ToString()
    {
      return String.Format("{0} on {1}", ScheduleName, idRuleBasedSchedule);
    }

    /// <summary>
    /// Retreives the programs with a given title and starting between given Start and End Times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <param name="idChannel">The id of the channel</param>
    /// <returns></returns>
    public static IList<Schedule> RetrieveByTitleAndTimesInterval(string title, DateTime startTime, DateTime endTime,
                                                                  int idChannel)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof(RuleBasedSchedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "programName", title);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "startTime", startTime);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Schedule>(stmt.Execute());
    }


  }
}