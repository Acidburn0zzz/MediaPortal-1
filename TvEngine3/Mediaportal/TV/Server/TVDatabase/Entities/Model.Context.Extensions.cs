//------------------------------------------------------------------------------
// <auto-generated>
//     Der Code wurde aus einer Vorlage generiert.
//
//     Änderungen an dieser Datei führen möglicherweise zu falschem Verhalten und gehen verloren, falls
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Data.EntityClient;
using System.Data.Metadata.Edm;
using System.Data.Objects.DataClasses;
using System.Data.Objects;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace Mediaportal.TV.Server.TVDatabase.Entities
{
    public static class SelfTrackingEntitiesContextExtensions
    {
        /// <summary>
        /// ApplyChanges übernimmt die Änderungen in einer verbundenen Reihe von Entitäten und wendet diese auf einen ObjectContext an.
        /// </summary>
        /// <typeparam name="TEntity">Erwarteter Typ von ObjectSet</typeparam>
        /// <param name="objectSet">Der ObjectSet, der auf den ObjectContext verweist, auf den Änderungen angewendet werden.</param>
        /// <param name="entity">Die Entität, die als Einstiegspunkt des Objektgraphen dient, der Änderungen enthält.</param>
        public static void ApplyChanges<TEntity>(this ObjectSet<TEntity> objectSet, TEntity entity) where TEntity : class, IObjectWithChangeTracker
        {
            if (objectSet == null)
            {
                throw new ArgumentNullException("objectSet");
            }
    
            objectSet.Context.ApplyChanges<TEntity>(objectSet.EntitySet.EntityContainer.Name + "." + objectSet.EntitySet.Name, entity);
        }
    
        /// <summary>
        /// ApplyChanges übernimmt die Änderungen in einer verbundenen Reihe von Entitäten und wendet diese auf einen ObjectContext an.
        /// </summary>
        /// <typeparam name="TEntity">Erwarteter Typ von EntitySet</typeparam>
        /// <param name="context">Der ObjectContext, auf den Änderungen angewendet werden.</param>
        /// <param name="entitySetName">Der EntitySet-Name der Entität.</param>
        /// <param name="entity">Die Entität, die als Einstiegspunkt des Objektgraphen dient, der Änderungen enthält.</param>
        public static void ApplyChanges<TEntity>(this ObjectContext context, string entitySetName, TEntity entity) where TEntity : IObjectWithChangeTracker
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
    
            if (String.IsNullOrEmpty(entitySetName))
            {
                throw new ArgumentException("Der Zeichenfolgenparameter darf nicht NULL oder leer sein.", "entitySetName");
            }
    
            if (entity == null)
            {
                throw new ArgumentNullException("entity");
            }
    
            bool lazyLoadingSetting = context.ContextOptions.LazyLoadingEnabled;
            try
            {
                context.ContextOptions.LazyLoadingEnabled = false;
    
                EntityIndex entityIndex = AddHelper.AddAllEntities(context, entitySetName, entity);
                RelationshipSet allRelationships = new RelationshipSet(context, entityIndex.AllEntities);
    
                #region Handle Initial Entity State
    
                foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities.Where(x => x.ChangeTracker.State == ObjectState.Deleted))
                {
                    HandleDeletedEntity(context, entityIndex, allRelationships, changedEntity);
                }
    
                foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities.Where(x => x.ChangeTracker.State != ObjectState.Deleted))
                {
                    HandleEntity(context, entityIndex, allRelationships, changedEntity);
                }
    
                #endregion
    
                #region Loop through each object state entries
    
                foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities)
                {
                    ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(changedEntity);
    
                    EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(changedEntity.GetType());
    
                    foreach (NavigationProperty navProp in entityType.NavigationProperties)
                    {
                        RelatedEnd relatedEnd = entry.GetRelatedEnd(navProp.Name);
                        if(!((AssociationType)relatedEnd.RelationshipSet.ElementType).IsForeignKey)
                        {
                            ApplyChangesToIndependentAssociation(context, (IObjectWithChangeTracker)changedEntity, entry, navProp, relatedEnd, allRelationships);
                        }
    
                    }
                }
                #endregion
    
                // Alle verbleibenden Beziehungen wieder in den geeigneten Zustand ändern
                foreach (var relationship in allRelationships)
                {
                    context.ObjectStateManager.ChangeRelationshipState(
                        relationship.End0,
                        relationship.End1,
                        relationship.AssociationSet.ElementType.FullName,
                        relationship.AssociationEndMembers[1].Name,
                        relationship.State);
                }
            }
            finally
            {
                context.ContextOptions.LazyLoadingEnabled = lazyLoadingSetting;
            }
        }
    
        private static void ApplyChangesToIndependentAssociation(ObjectContext context, IObjectWithChangeTracker changedEntity, ObjectStateEntry entry, NavigationProperty navProp,
            IRelatedEnd relatedEnd, RelationshipSet allRelationships)
        {
            ObjectChangeTracker changeTracker = changedEntity.ChangeTracker;
    
            if (changeTracker.State == ObjectState.Added)
            {
                // Beziehungen sollten hinzugefügt bleiben. Entfernen Sie sie daher aus der Liste von allRelationships
                foreach (object relatedEntity in relatedEnd)
                {
                    ObjectStateEntry addedRelationshipEntry =
                                context.ObjectStateManager.ChangeRelationshipState(
                                    changedEntity,
                                    relatedEntity,
                                    navProp.Name,
                                    EntityState.Added);
    
                    allRelationships.Remove(addedRelationshipEntry);
                }
            }
            else
            {
                if (navProp.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
                {
                    //Entfernungsvorgang für FixupCollections behandeln
                    ObjectList collectionPropertyChanges = null;
                    if (changeTracker.ObjectsRemovedFromCollectionProperties.TryGetValue(navProp.Name, out collectionPropertyChanges))
                    {
                        foreach (var removedEntityFromAssociation in collectionPropertyChanges)
                        {
                            ObjectStateEntry deletedRelationshipEntry =
                                context.ObjectStateManager.ChangeRelationshipState(
                                    changedEntity,
                                    removedEntityFromAssociation,
                                    navProp.Name,
                                    EntityState.Deleted);
    
                            allRelationships.Remove(deletedRelationshipEntry);
                        }
                    }
    
                    //Hinzufügevorgang für FixupCollection behandeln
                    if (changeTracker.ObjectsAddedToCollectionProperties.TryGetValue(navProp.Name, out collectionPropertyChanges))
                    {
                        foreach (var addedEntityFromAssociation in collectionPropertyChanges)
                        {
                            ObjectStateEntry addedRelationshipEntry =
                                context.ObjectStateManager.ChangeRelationshipState(
                                    changedEntity,
                                    addedEntityFromAssociation,
                                    navProp.Name,
                                    EntityState.Added);
    
                            allRelationships.Remove(addedRelationshipEntry);
                        }
                    }
                }
                else
                {
    
                    // Ursprüngliche Beziehungswerte behandeln
                    object originalReferenceValue;
                    if (changeTracker.OriginalValues.TryGetValue(navProp.Name, out originalReferenceValue))
                    {
                        if (originalReferenceValue != null)
                        {
                            //Löschen der Zuordnung erfassen
                            ObjectStateEntry deletedRelationshipEntry =
                                context.ObjectStateManager.ChangeRelationshipState(
                                    entry.Entity,
                                    originalReferenceValue,
                                    navProp.Name,
                                    EntityState.Deleted);
    
                            allRelationships.Remove(deletedRelationshipEntry);
                        }
    
                        //Hinzufügen der Zuordnung erfassen
                        object currentReferenceValue = null;
                        foreach (object o in relatedEnd)
                        {
                            currentReferenceValue = o;
                            break;
                        }
                        if (currentReferenceValue != null)
                        {
                            ObjectStateEntry addedRelationshipEntry =
                                context.ObjectStateManager.ChangeRelationshipState(
                                    changedEntity,
                                    currentReferenceValue,
                                    navProp.Name,
                                    EntityState.Added);
    
                            allRelationships.Remove(addedRelationshipEntry);
                        }
                        // wenn der aktuelle Wert des Verweises NULL ist, muss der Benutzer den Entitätsverweis auf NULL festlegen
                        // der bereits vom Löschen der Beziehung behandelt wird
                    }
                }
            }
        }
    
        // Extrahiert die Beziehungsschlüsselinformationen aus den ExtendedProperties- und OriginalValues-Datensätzen jedes ObjectChangeTracker.
        // Dies wird folgendermaßen ausgeführt:
        //  1. Erstellen einer vorhandenen Beziehung, die in den ExtendedProperties angegeben wird
        //  2. Bestimmen, ob eine vorherige Beziehung vorhanden war, und ob eine gelöschte Beziehung zwischen der Entität und der vorherigen Entität oder des Schlüsselwerts erstellt wurde
        private static void HandleRelationshipKeys(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
        {
            ObjectChangeTracker changeTracker = entity.ChangeTracker;
            if (changeTracker.State == ObjectState.Unchanged ||
                changeTracker.State == ObjectState.Modified ||
                changeTracker.State == ObjectState.Deleted)
            {
                ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
                EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());
                RelationshipManager relationshipManager = context.ObjectStateManager.GetRelationshipManager(entity);
    
                foreach (var entityReference in EnumerateSaveReferences(relationshipManager))
                {
                    AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
                    AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
                    AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;
    
                    // Feststellen, ob für den Kandidat eine NavigationProperty vorhanden ist
                    NavigationProperty navigationProperty = entityType.NavigationProperties.
                                               SingleOrDefault(x => x.RelationshipType == associationSet.ElementType &&
                                                               x.FromEndMember == fromEnd &&
                                                               x.ToEndMember == toEnd);
    
                    // Nur Beziehungsschlüssel in einem dieser Fälle behandeln
                    // 1. Es ist keine Navigationseigenschaft vorhanden
                    // 2. Die Navigationseigenschaft besitzt einen aktuellen NULL-Verweiswert, und es finden keine Entfernungs- oder Hinzufügevorgänge statt
                    // 3. Die Navigationseigenschaft besitzt einen aktuellen Verweiswert, doch es findet kein Entfernungsvorgang statt
    
                    EntityKey currentKey = GetSavedReferenceKey(entityIndex, entityReference, entity, navigationProperty, changeTracker.ExtendedProperties);
    
                    // Jeden ursprünglichen Wert aus den Änderungsverfolgungsinformationen abrufen
                    object originalValue = null;
                    EntityKey originalKey = null;
                    bool hasOriginalValue = false;
                    if (changeTracker.OriginalValues != null)
                    {
                        // Zuerst den ursprünglichen Wert von der NavigationProperty abrufen
                        if (navigationProperty != null)
                        {
                            hasOriginalValue = changeTracker.OriginalValues.TryGetValue(navigationProperty.Name, out originalValue);
                        }
                        // Den ursprünglichen Wert im zweiten Schritt vom Verweisschlüssel abrufen
                        if (!hasOriginalValue || originalValue == null)
                        {
                            originalKey = GetSavedReferenceKey(entityIndex, entityReference, entity, navigationProperty, changeTracker.OriginalValues);
                        }
                    }
    
                    // Aktuelle Beziehung erstellen
                    if (currentKey != null)
                    {
                        // Wenn der Schlüssel für eine gelöschte Entität ist, verschieben Sie diesen Schlüssel zu einem originalValue, und beheben Sie die Werte des Entitätenschlüssels
                        // Erstellen Sie andernfalls eine neue Beziehung
                        ObjectStateEntry currentEntry;
                        if (context.ObjectStateManager.TryGetObjectStateEntry(currentKey, out currentEntry) &&
                           currentEntry.Entity != null &&
                           currentEntry.State == EntityState.Deleted)
                        {
                            entityReference.EntityKey = null;
                            MoveSavedReferenceKey(entityReference, entity, navigationProperty, changeTracker.ExtendedProperties, changeTracker.OriginalValues);
                            originalKey = currentKey;
                        }
                        else
                        {
                            CreateRelationship(context, entityReference, entry.EntityKey, currentKey, originalKey == null ? EntityState.Unchanged : EntityState.Added);
                        }
                    }
                    else
                    {
                        // Aktuellen Schlüssel suchen
                        // Der EntityKey kann nicht direkt abgerufen werden, da er NULL ist, wenn er auf eine Entität mit dem Namen "Hinzugefügt" zeigt
                        currentKey = entityReference.GetCurrentEntityKey(context);
                    }
    
                    // Ursprüngliche Beziehung erstellen
                    if (originalKey != null)
                    {
                        // Wenn der Schlüssel für eine gelöschte Entität ist, denken Sie daran, eine gelöschte Beziehung zu erstellen.
                        // Verwenden Sie andernfalls entityReference, um die gelöschte Beziehung einzurichten.
                        ObjectStateEntry originalEntry = null;
                        ObjectStateEntry deletedRelationshipEntry = null;
                        if (context.ObjectStateManager.TryGetObjectStateEntry(originalKey, out originalEntry) &&
                           originalEntry.Entity != null &&
                           originalEntry.State == EntityState.Deleted)
                        {
                            allRelationships.Add(entityReference, entry.Entity, originalEntry.Entity, EntityState.Deleted);
                        }
                        else
                        {
                            // Wenn Sie eine gelöschte Beziehung für einen Schlüssel erstellen möchten, trennen Sie zuerst die vorhandene Beziehung zwischen "entry" und "currentKey"
                            EntityState currentRelationshipState = DetachRelationship(context, entityReference, entry, currentKey);
    
                            // Wenn die Beziehung 1 bis 0..1 ist, trennen Sie die Beziehung von currentKey bis zu ihrem Ziel (targetKey)
                            EntityState targetRelationshipState = EntityState.Detached;
                            EntityReference targetReference = null;
                            EntityKey targetKey = null;
                            if (originalEntry != null &&
                                originalEntry.Entity != null &&
                                originalEntry.RelationshipManager != null &&
                                associationSet.AssociationSetEnds[fromEnd.Name].CorrespondingAssociationEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                            {
                                targetReference = originalEntry.RelationshipManager.GetRelatedEnd(entityReference.RelationshipName, entityReference.SourceRoleName) as EntityReference;
                                targetKey = targetReference.GetCurrentEntityKey(context);
                                if (targetKey != null)
                                {
                                    targetRelationshipState = DetachRelationship(context, targetReference, originalEntry, targetKey);
                                }
                            }
    
    
                            // Erstellen Sie die gelöschte Beziehung zwischen "entry" und "originalKey"
                            deletedRelationshipEntry = CreateRelationship(context, entityReference, entry.EntityKey, originalKey, EntityState.Deleted);
    
                            // Setzen Sie die vorherige Beziehung zwischen entry und currentKey zurück
                            CreateRelationship(context, entityReference, entry.EntityKey, currentKey, currentRelationshipState);
    
                            // Setzen Sie die vorherige Beziehung zwischen originalEntry und targetKey zurück
                            if (targetKey != null)
                            {
                                CreateRelationship(context, targetReference, originalEntry.EntityKey, targetKey, targetRelationshipState);
                            }
                        }
                        if (deletedRelationshipEntry != null)
                        {
                            // Entfernen Sie die gelöschte Beziehung aus denen, die später in ApplyChanges verarbeitet werden müssen
                            allRelationships.Remove(deletedRelationshipEntry);
                        }
                    }
                    else if (currentKey == null && originalValue != null && entityReference.IsDependentEndOfReferentialConstraint())
                    {
                        // dies wird nicht in das Diagramm eingebunden, da kein aktueller Wert vorhanden ist. Es ist jedoch ein ursprünglicher Wert vorhanden,
                        // sodass der Code für die Beziehungsverarbeitung eine Beziehung löschen möchte.
                        // Dies kann hinzugefügt werden, damit eine Beziehung in den Status "Gelöscht" geändert wird.
                        context.ObjectStateManager.ChangeRelationshipState(
                                                            entry.Entity,
                                                            originalValue,
                                                            entityReference.RelationshipName,
                                                            entityReference.TargetRoleName,
                                                            EntityState.Added);
                    }
                }
            }
        }
    
        private static ObjectStateEntry CreateRelationship(ObjectContext context, EntityReference entityReference, EntityKey fromKey, EntityKey toKey, EntityState state)
        {
            if (state != EntityState.Detached)
            {
                AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
                AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
                AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;
    
                // die Beziehung auf die ursprüngliche Beziehung im Status "Unverändert" festlegen
                Debug.Assert(toKey != null, "Warum/Wie wird ein Löschvorgang mit einem originalKey gleich NULL ausgeführt?");
    
                if (toKey.IsTemporary)
                {
                    // Alle vorhandenen Beziehungen löschen
                    entityReference.EntityKey = null;
    
                    // Wenn die Zielentität "Hinzugefügt" ist, verwenden Sie "Hinzufügen" für RelatedEnd
                    ObjectStateEntry targetEntry;
                    context.ObjectStateManager.TryGetObjectStateEntry(toKey, out targetEntry);
                    Debug.Assert(targetEntry != null, "Hätte den Zustandseintrag finden sollen");
                    ((IRelatedEnd)entityReference).Add(targetEntry.Entity);
                }
                else
                {
                    entityReference.EntityKey = toKey;
                }
    
                ObjectStateEntry relationshipEntry;
                bool found = context.TryGetObjectStateEntry(fromKey, toKey, associationSet, fromEnd, toEnd, out relationshipEntry);
                Debug.Assert(found, "Die erstellte Beziehung wurde nicht gefunden.");
    
                switch (state)
                {
                    case EntityState.Added:
                        break;
                    case EntityState.Unchanged:
                        relationshipEntry.AcceptChanges();
                        break;
                    case EntityState.Deleted:
                        relationshipEntry.AcceptChanges();
                        entityReference.EntityKey = null;
                        break;
                }
                return relationshipEntry;
            }
            return null;
        }
    
        private static EntityState DetachRelationship(ObjectContext context, EntityReference entityReference, ObjectStateEntry fromEntry, EntityKey toKey)
        {
            EntityState currentRelationshipState = EntityState.Detached;
    
            if (toKey != null)
            {
                AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
                AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
                AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;
    
                ObjectStateEntry currentRelationshipEntry = null;
    
                if (context.TryGetObjectStateEntry(fromEntry.EntityKey, toKey, associationSet, fromEnd, toEnd, out currentRelationshipEntry))
                {
                    currentRelationshipState = currentRelationshipEntry.State;
    
                    entityReference.EntityKey = null;
                    if (currentRelationshipEntry.State == EntityState.Deleted)
                    {
                        currentRelationshipEntry.AcceptChanges();
                    }
                    Debug.Assert(currentRelationshipEntry.State == EntityState.Detached, "Die Beziehung wurde nicht getrennt.");
                }
            }
            return currentRelationshipState;
        }
    
        private static string CreateReferenceKeyLookup(string keyMemberName, EntityReference reference, NavigationProperty navigationProperty)
        {
            // verwenden Sie den benutzerfreundlicheren Navigationseigenschaftsnamen, um den Member zu qualifizieren
            // falls verfügbar
            if (navigationProperty != null)
            {
                return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navigationProperty.Name, keyMemberName);
            }
            else
            {
                return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", reference.RelationshipSet.ElementType.FullName, reference.TargetRoleName, keyMemberName);
            }
        }
    
        // ruft den Schlüssel ab, der dem übergebenen EntityReference entspricht
        // diese Schlüssel können während des ObjectMaterialized-Ereignisses oder durch Beziehungs-Fixup festgelegt werden
        private static EntityKey GetSavedReferenceKey(EntityIndex entityIndex, EntityReference reference, object entity, NavigationProperty navigationProperty, IDictionary<string, object> values)
        {
            Debug.Assert(navigationProperty == null || reference.RelationshipSet.ElementType == navigationProperty.RelationshipType, "der Verweis und die navigationProperty sollten sich entsprechen");
    
            EntitySet entitySet = ((AssociationSet)reference.RelationshipSet).AssociationSetEnds[reference.TargetRoleName].EntitySet;
    
            List<EntityKeyMember> foundKeyMembers = new List<EntityKeyMember>(1);
            bool foundNone = true;
            bool missingSome = false;
            foreach (var keyMember in entitySet.ElementType.KeyMembers)
            {
                string lookupKey = CreateReferenceKeyLookup(keyMember.Name, reference, navigationProperty);
                object value;
                if (values.TryGetValue(lookupKey, out value))
                {
                    foundKeyMembers.Add(new EntityKeyMember(keyMember.Name, value));
                    foundNone = false;
                }
                else
                {
                    missingSome = true;
                }
            }
    
            if (foundNone)
            {
                // es wurde kein Schlüssel gefunden
                return null;
            }
            else if (missingSome)
            {
                throw new InvalidOperationException(
                    String.Format(
                        CultureInfo.CurrentCulture,
                        "Die OriginalValues-Auflistung oder ExtendedProperties-Auflistung für den Typ '{0}' enthielt nur einen Teilschlüssel, um der Beziehung '{1}' zu entsprechen, die auf die Rolle '{2}' abzielt.",
                        entity.GetType().FullName,
                        reference.RelationshipName,
                        reference.TargetRoleName));
            }
    
            EntityKey key = entityIndex.ConvertEntityKey(new EntityKey(reference.GetEntitySetName(), foundKeyMembers));
            return key;
        }
    
        // Verschiebt den Schlüssel, der dem übergebenen EntityReference entspricht, von einer Quellauflistung in eine Zielauflistung
        private static void MoveSavedReferenceKey(EntityReference reference, object entity, NavigationProperty navigationProperty, IDictionary<string, object> sourceValues, IDictionary<string, object> targetValues)
        {
            Debug.Assert(navigationProperty == null || reference.RelationshipSet.ElementType == navigationProperty.RelationshipType, " reference und navigationProperty sollten einander entsprechen");
    
            EntitySet entitySet = ((AssociationSet)reference.RelationshipSet).AssociationSetEnds[reference.TargetRoleName].EntitySet;
    
            bool missingSome = false;
            foreach (var keyMember in entitySet.ElementType.KeyMembers)
            {
                string lookupKey = CreateReferenceKeyLookup(keyMember.Name, reference, navigationProperty);
                object value;
                if (sourceValues.TryGetValue(lookupKey, out value))
                {
                    if (targetValues.ContainsKey(lookupKey))
                    {
                        targetValues[lookupKey] = value;
                    }
                    else
                    {
                        targetValues.Add(lookupKey, value);
                    }
                    sourceValues.Remove(lookupKey);
                }
                else
                {
                    missingSome = true;
                }
            }
    
            if (missingSome)
            {
                throw new InvalidOperationException(
                    String.Format(
                        CultureInfo.CurrentCulture,
                        " Die OriginalValues-Auflistung oder ExtendedProperties-Auflistung für den Typ '{0}' enthielt nur einen Teilschlüssel, um der Beziehung '{1}' zu entsprechen, die auf die Rolle '{2}' abzielt.",
                        entity.GetType().FullName,
                        reference.RelationshipName,
                        reference.TargetRoleName));
            }
        }
    
        private static IEnumerable<EntityReference> EnumerateSaveReferences(RelationshipManager manager)
        {
            return manager.GetAllRelatedEnds().OfType<EntityReference>()
                    .Where(er => er.RelationshipSet.ElementType.RelationshipEndMembers[er.SourceRoleName].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                        !((AssociationSet)er.RelationshipSet).ElementType.IsForeignKey);
        }
    
        internal static void StoreReferenceKeyValues(this ObjectContext context, IObjectWithChangeTracker entity)
        {
            if(entity == null)
            {
                throw new ArgumentNullException("entity");
            }
    
            ObjectStateEntry entry;
            if (!context.ObjectStateManager.TryGetObjectStateEntry(entity, out entry))
            {
                // muss eine nicht nachverfolgungsbezogene Abfrage sein. Die Informationen zum Verweisschlüssel sind nicht verfügbar
                return;
            }
    
            var relationshipManager = entry.RelationshipManager;
            EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());
            foreach (EntityReference entityReference in EnumerateSaveReferences(relationshipManager))
            {
                NavigationProperty navigationProperty = entityType.NavigationProperties.FirstOrDefault(n => n.RelationshipType == entityReference.RelationshipSet.ElementType &&
                        n.FromEndMember.Name == entityReference.SourceRoleName &&
                        n.ToEndMember.Name == entityReference.TargetRoleName);
    
                object value = entityReference.GetValue();
                if ((navigationProperty == null || value == null) && entityReference.EntityKey != null)
                {
                    foreach (var item in entityReference.EntityKey.EntityKeyValues)
                    {
                        string key = CreateReferenceKeyLookup(item.Key, entityReference, navigationProperty);
                        entity.ChangeTracker.ExtendedProperties.Add(key, item.Value);
                    }
                }
            }
        }
    
        private static void HandleEntity(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
        {
            ChangeEntityStateBasedOnObjectState(context, entity);
            HandleRelationshipKeys(context, entityIndex, allRelationships, entity);
            UpdateOriginalValues(context, entity);
        }
    
        private static void HandleDeletedEntity(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
        {
            HandleRelationshipKeys(context, entityIndex, allRelationships, entity);
            ChangeEntityStateBasedOnObjectState(context, entity);
            UpdateOriginalValues(context, entity);
        }
    
        private static void UpdateOriginalValues(ObjectContext context, IObjectWithChangeTracker entity)
        {
            if (entity.ChangeTracker.State == ObjectState.Unchanged ||
                entity.ChangeTracker.State == ObjectState.Added ||
                entity.ChangeTracker.OriginalValues == null)
            {
                // keine Schritte erforderlich
                return;
            }
    
            // es müssen nur skalare und komplexe Eigenschaften bearbeitet werden
    
            ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
            OriginalValueRecord originalValueRecord = entry.GetUpdatableOriginalValues();
            EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());
    
            // jede Eigenschaft überprüfen und feststellen, ob ein ursprünglicher Wert dafür vorhanden ist
            // Wird in diesem Fall festgelegt. Legen Sie in den ComplexType-Eigenschaften ursprüngliche Werte fest
            // auch für jedes Element
            //
            // es wird erwartet, dass die ursprünglichen Werte eine geringe Dichte aufweisen, da versucht wird,
            // nur die ursprünglichen Werte für die erforderlichen Objekte zu erfassen (Parallelität, Prozedur, Bedingung, zusätzliche?)
            foreach(EdmProperty property in entityType.Properties)
            {
                object value;
                if(property.TypeUsage.EdmType is PrimitiveType && entity.ChangeTracker.OriginalValues.TryGetValue(property.Name, out value))
                {
                    originalValueRecord.SetValue(property, value);
                }
                else if(property.TypeUsage.EdmType is ComplexType)
                {
                    OriginalValueRecord complexOriginalValues = originalValueRecord.GetOriginalValueRecord(property.Name);
                    UpdateOriginalValues((ComplexType)property.TypeUsage.EdmType, entity.GetType().FullName, property.Name, entity.ChangeTracker.OriginalValues, complexOriginalValues);
                }
            }
        }
    
        private static void UpdateOriginalValues(ComplexType complexType, string entityTypeName, string propertyPathToType, IDictionary<string, object> originalValueSource, OriginalValueRecord complexOriginalValueRecord)
        {
            // complexOriginalValueRecord ist möglicherweise NULL
            // ein complexOriginalValueRecord mit dem Wert NULL tritt nur auf, wenn ein NULL-Verweis
            // einer ComplexType-Eigenschaft zugewiesen und anschließend an ApplyChanges übergeben wird.
            //
            // jede Eigenschaft überprüfen und feststellen, ob ein ursprünglicher Wert dafür vorhanden ist
            // Wird in diesem Fall festgelegt. Legen Sie in den ComplexType-Eigenschaften ursprüngliche Werte fest
            // auch für jedes Element
            foreach (EdmProperty property in complexType.Properties)
            {
                object value;
                string propertyPath = String.Format(CultureInfo.InvariantCulture, "{0}.{1}", propertyPathToType, property.Name);
                if (property.TypeUsage.EdmType is PrimitiveType && originalValueSource.TryGetValue(propertyPath, out value))
                {
                    if (complexOriginalValueRecord != null)
                    {
                        complexOriginalValueRecord.SetValue(property, value);
                    }
                    else if (value != null)
                    {
                        Debug.Assert(complexOriginalValueRecord == null, "wird nur ausgelöst, wenn der Wert nicht NULL und der Datensatz NULL ist");
                        throw new InvalidOperationException(
                            String.Format(
                            CultureInfo.CurrentCulture,
                            "Der ursprüngliche Wert für das in der Eigenschaft '{0}' für den Typ '{1}' gespeicherte Objekt kann nicht festgelegt werden, da die Eigenschaft NULL ist.",
                            propertyPathToType,
                            entityTypeName));
                    }
                }
                else if (property.TypeUsage.EdmType is ComplexType)
                {
                    OriginalValueRecord nestedOriginalValueRecord = null;
                    if (complexOriginalValueRecord != null)
                    {
                        nestedOriginalValueRecord = complexOriginalValueRecord.GetOriginalValueRecord(property.Name);
                    }
                    // Kette der komplexen Typen durchlaufen...
                    UpdateOriginalValues((ComplexType)property.TypeUsage.EdmType, entityTypeName, propertyPath, originalValueSource, nestedOriginalValueRecord);
                }
            }
        }
    
        private static OriginalValueRecord GetOriginalValueRecord(this OriginalValueRecord record, string name)
        {
            int ordinal = record.GetOrdinal(name);
            if (!record.IsDBNull(ordinal))
            {
                return record.GetDataRecord(ordinal) as OriginalValueRecord;
            }
            else
            {
                return null;
            }
        }
    
        private static void SetValue(this OriginalValueRecord record, EdmProperty edmProperty, object value)
        {
            if (value == null)
            {
                Type entityClrType = ((PrimitiveType)edmProperty.TypeUsage.EdmType).ClrEquivalentType;
                if (entityClrType.IsValueType &&
                    !(entityClrType.IsGenericType && typeof(Nullable<>) == entityClrType.GetGenericTypeDefinition()))
                {
                    // Überspringen Sie das Festlegen von NULL für ursprüngliche Werte in nicht nullbaren CLR-Typen, da ObjectStateEntry dies nicht zulässt.
                    return;
                }
            }
    
            int ordinal = record.GetOrdinal(edmProperty.Name);
            record.SetValue(ordinal, value);
        }
    
    
        private static void ChangeEntityStateBasedOnObjectState(ObjectContext context, IObjectWithChangeTracker entity)
        {
            switch (entity.ChangeTracker.State)
            {
                case (ObjectState.Added):
                    // No-op: Der Zustandseintrag ist bereits als hinzugefügt markiert
                    Debug.Assert(context.ObjectStateManager.GetObjectStateEntry(entity).State == EntityState.Added, "Der Zustand hätte 'Hinzugefügt' sein sollen");
                    break;
                case (ObjectState.Unchanged):
                    context.ObjectStateManager.ChangeObjectState(entity, EntityState.Unchanged);
                    break;
                case (ObjectState.Modified):
                    context.ObjectStateManager.ChangeObjectState(entity, EntityState.Modified);
                    break;
                case (ObjectState.Deleted):
                    context.ObjectStateManager.ChangeObjectState(entity, EntityState.Deleted);
                    break;
    
            }
        }
    
        private static EntityType GetCSpaceEntityType(this MetadataWorkspace workspace, Type type)
        {
            EntityType ospaceEntityType = null;
            StructuralType cspaceEntityType = null;
            EntityType entityType = null;
            if (workspace.TryGetItem<EntityType>(
                type.FullName,
                DataSpace.OSpace,
                out ospaceEntityType))
            {
                if (workspace.TryGetEdmSpaceType(
                    ospaceEntityType,
                    out cspaceEntityType))
                {
                    entityType = cspaceEntityType as EntityType;
                }
            }
            if(entityType == null)
            {
                throw new ArgumentException(String.Format(CultureInfo.CurrentCulture, "Für den Typ '{0}' wurde kein CSpace-Typ gefunden.", type.FullName));
            }
            return entityType;
        }
    
        private static object GetValue(this System.Data.Objects.DataClasses.EntityReference entityReference)
        {
            foreach (object value in entityReference)
            {
                return value;
            }
            return null;
        }
    
        private static EntityKey GetCurrentEntityKey(this System.Data.Objects.DataClasses.EntityReference entityReference, ObjectContext context)
        {
            EntityKey currentKey = null;
            object currentValue = entityReference.GetValue();
            if (currentValue != null)
            {
                ObjectStateEntry relatedEntry = context.ObjectStateManager.GetObjectStateEntry(currentValue);
                currentKey = relatedEntry.EntityKey;
            }
            else
            {
                currentKey = entityReference.EntityKey;
            }
            return currentKey;
        }
    
        private static RelatedEnd GetRelatedEnd(this ObjectStateEntry entry, string navigationPropertyIdentity)
        {
            NavigationProperty navigationProperty =
                            GetNavigationProperty(entry.ObjectStateManager.MetadataWorkspace.GetCSpaceEntityType(entry.Entity.GetType()), navigationPropertyIdentity);
            return entry.RelationshipManager.GetRelatedEnd(
                navigationProperty.RelationshipType.FullName, navigationProperty.ToEndMember.Name) as RelatedEnd;
        }
    
        private static NavigationProperty GetNavigationProperty(this EntityType entityType, string navigationPropertyIdentity)
        {
            NavigationProperty navigationProperty;
            if (!entityType.NavigationProperties.TryGetValue(navigationPropertyIdentity, false, out navigationProperty))
            {
                throw new InvalidOperationException(
                    String.Format(
                        CultureInfo.CurrentCulture,
                        "Die Navigationseigenschaft '{0}' in EntityType '{1}' wurde nicht gefunden.",
                        navigationPropertyIdentity,
                        entityType.FullName));
            }
            return navigationProperty;
        }
    
        private static string GetEntitySetName(this RelatedEnd relatedEnd)
        {
            EntitySet entitySet = ((AssociationSet)relatedEnd.RelationshipSet).AssociationSetEnds[relatedEnd.TargetRoleName].EntitySet;
            return entitySet.EntityContainer.Name + "." + entitySet.Name;
        }
    
        private static bool IsDependentEndOfReferentialConstraint(this RelatedEnd relatedEnd)
        {
            if (null != relatedEnd.RelationshipSet)
            {
                // HINWEIS: Die Auflistung für referenzielle Einschränkungen enthält normalerweise 0 oder 1 Element,
                // Leistungsprobleme sind hier nicht zu erwarten
                foreach (ReferentialConstraint constraint in ((AssociationType)relatedEnd.RelationshipSet.ElementType).ReferentialConstraints)
                {
                    if (constraint.ToRole.Name == relatedEnd.SourceRoleName)
                    {
                        // Beispiel:
                        //    Client<C_ID> --- Order<O_ID, Client_ID>
                        //    RI-Einschränkung: Prinzipal/Von <Client.C_ID>, Abhängig/Bis <Order.Client_ID>
                        // Wenn das aktuelle RelatedEnd ein CollectionOrReference in Reihenfolgenbeziehungen ist,
                        // constarint.ToRole == this._fromEndProperty == Order
                        return true;
                    }
                }
            }
            return false;
        }
    
        private static bool TryGetObjectStateEntry(this ObjectContext context, EntityKey from, EntityKey to, AssociationSet associationSet, AssociationEndMember fromEnd, AssociationEndMember toEnd, out ObjectStateEntry entry)
        {
            entry = null;
            foreach (var relationshipEntry in (from e in context.ObjectStateManager.GetObjectStateEntries(EntityState.Added | EntityState.Unchanged)
                                               where e.IsRelationship && e.EntitySet == associationSet
                                               select e))
            {
                CurrentValueRecord currentValues = relationshipEntry.CurrentValues;
                int fromOrdinal = currentValues.GetOrdinal(fromEnd.Name);
                int toOrdinal = currentValues.GetOrdinal(toEnd.Name);
                if (((EntityKey)currentValues.GetValue(fromOrdinal)) == from &&
                    ((EntityKey)currentValues.GetValue(toOrdinal)) == to)
                {
                    entry = relationshipEntry;
                    return true;
                }
            }
            return false;
        }
    
        private sealed class AddHelper
        {
            private readonly ObjectContext _context;
            private readonly EntityIndex _entityIndex;
    
            // Wird während der Verarbeitung von Hinzufügevorgängen verwendet
            private readonly Queue<Tuple<string, IObjectWithChangeTracker>> _entitiesToAdd;
            private readonly Queue<Tuple<ObjectStateEntry, string, IEnumerable<object>>> _entitiesDuringAdd;
    
            public static EntityIndex AddAllEntities(ObjectContext context, string entitySetName, IObjectWithChangeTracker entity)
            {
                AddHelper addHelper = new AddHelper(context);
    
                try
                {
                    // Das Stammelement einschließen, um den Übernahmevorgang zu starten
                    addHelper.QueueAdd(entitySetName, entity);
    
                    // Alles hinzufügen
                    while (addHelper.HasMore)
                    {
                        Tuple<string, IObjectWithChangeTracker> entityInSet = addHelper.NextAdd();
                        // Objekt nur hinzufügen, wenn es nicht bereits im Kontext enthalten ist
                        ObjectStateEntry entry = null;
                        if (!context.ObjectStateManager.TryGetObjectStateEntry(entityInSet.Item2, out entry))
                        {
                            context.AddObject(entityInSet.Item1, entityInSet.Item2);
                        }
                    }
                }
                finally
                {
                    addHelper.Detach();
                }
                return addHelper.EntityIndex;
            }
    
            private AddHelper(ObjectContext context)
            {
                _context = context;
                _context.ObjectStateManager.ObjectStateManagerChanged += this.HandleStateManagerChange;
    
                _entityIndex = new EntityIndex(context);
                _entitiesToAdd = new Queue<Tuple<string, IObjectWithChangeTracker>>();
                _entitiesDuringAdd = new Queue<Tuple<ObjectStateEntry, string, IEnumerable<object>>>();
            }
    
            private void Detach()
            {
                _context.ObjectStateManager.ObjectStateManagerChanged -= this.HandleStateManagerChange;
            }
    
            private void HandleStateManagerChange(object sender, CollectionChangeEventArgs args)
            {
                if (args.Action == CollectionChangeAction.Add)
                {
                    IObjectWithChangeTracker entity = args.Element as IObjectWithChangeTracker;
                    ObjectStateEntry entry = _context.ObjectStateManager.GetObjectStateEntry(entity);
                    ObjectChangeTracker changeTracker = entity.ChangeTracker;
    
                    changeTracker.ChangeTrackingEnabled = false;
                    _entityIndex.Add(entry, changeTracker);
    
                    // Aus der Warteschlange entfernte Referenzwerte
                    var navPropNames = _context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType()).NavigationProperties.Select(n => n.Name);
                    var entityRefOriginalValues = changeTracker.OriginalValues.Where(kvp => navPropNames.Contains(kvp.Key));
                    foreach (KeyValuePair<string, object> originalValueWithName in entityRefOriginalValues)
                    {
                        if (originalValueWithName.Value != null)
                        {
                            _entitiesDuringAdd.Enqueue(new Tuple<ObjectStateEntry, string, IEnumerable<object>>(
                                entry,
                                originalValueWithName.Key,
                                new object[] { originalValueWithName.Value }));
                        }
                    }
    
                    // Aus der Warteschlange entfernte Auflistungswerte
                    foreach (KeyValuePair<string, ObjectList> collectionPropertyChangesWithName in changeTracker.ObjectsRemovedFromCollectionProperties)
                    {
                        _entitiesDuringAdd.Enqueue(new Tuple<ObjectStateEntry, string, IEnumerable<object>>(
                            entry,
                            collectionPropertyChangesWithName.Key,
                            collectionPropertyChangesWithName.Value));
                    }
                }
            }
    
            private EntityIndex EntityIndex
            {
                get { return _entityIndex; }
            }
    
            private bool HasMore
            {
                get { ProcessNewAdds(); return _entitiesToAdd.Count > 0; }
            }
    
            private void QueueAdd(string entitySetName, IObjectWithChangeTracker entity)
            {
                if (!_entityIndex.Contains(entity))
                {
                    // Entität in die Warteschlange setzen, damit die Elemente der "entfernten Auflistung" hinzugefügt werden können
                    _entitiesToAdd.Enqueue(new Tuple<string, IObjectWithChangeTracker>(entitySetName, entity));
                }
            }
    
            private Tuple<string, IObjectWithChangeTracker> NextAdd()
            {
                ProcessNewAdds();
                return _entitiesToAdd.Dequeue();
            }
    
            private void ProcessNewAdds()
            {
                while (_entitiesDuringAdd.Count > 0)
                {
                    Tuple<ObjectStateEntry, string, IEnumerable<object>> relatedEntities = _entitiesDuringAdd.Dequeue();
                    RelatedEnd relatedEnd = relatedEntities.Item1.GetRelatedEnd(relatedEntities.Item2);
                    string entitySetName = relatedEnd.GetEntitySetName();
    
                    foreach (var targetEntity in relatedEntities.Item3)
                    {
                        QueueAdd(entitySetName, targetEntity as IObjectWithChangeTracker);
                    }
                }
            }
        }
    
        private sealed class EntityIndex
        {
            private readonly ObjectContext _context;
    
            // Gruppe aller Entitäten
            private readonly HashSet<IObjectWithChangeTracker> _allEntities;
    
            // Index des letzten Schlüssels, der im Kontext verwendet wird (kann echt für nicht hinzugefügte Elemente und temporär für hinzugefügte Elemente sein)
            // für den anfänglichen temporären Schlüssel
            private readonly Dictionary<EntityKey, EntityKey> _temporaryKeyMap;
    
            public EntityIndex(ObjectContext context)
            {
                _context = context;
    
                _allEntities = new HashSet<IObjectWithChangeTracker>();
                _temporaryKeyMap = new Dictionary<EntityKey, EntityKey>();
            }
    
            public void Add(ObjectStateEntry entry, ObjectChangeTracker changeTracker)
            {
                EntityKey temporaryKey = entry.EntityKey;
                EntityKey finalKey;
    
                if (!_allEntities.Contains(entry.Entity))
                {
                    // Nachverfolgen, dass die Entität durch diese Übernahme behandelt wird
                    _allEntities.Add(entry.Entity as IObjectWithChangeTracker);
                }
    
                if (changeTracker.State == ObjectState.Added)
                {
                    finalKey = temporaryKey;
                }
                else
                {
                    finalKey = _context.CreateEntityKey(temporaryKey.EntityContainerName + "." + temporaryKey.EntitySetName, entry.Entity);
                }
                if (!_temporaryKeyMap.ContainsKey(finalKey))
                {
                    _temporaryKeyMap.Add(finalKey, temporaryKey);
                }
            }
    
            public bool Contains(object entity)
            {
                return _allEntities.Contains(entity);
            }
    
            public IEnumerable<IObjectWithChangeTracker> AllEntities
            {
                get { return _allEntities; }
            }
    
            // Konvertiert den übergebenen EntityKey in den EntityKey, der vom aktuellen Zustand von ApplyChanges verwendet werden kann
            public EntityKey ConvertEntityKey(EntityKey targetKey)
            {
                ObjectStateEntry targetEntry;
                if (!_context.ObjectStateManager.TryGetObjectStateEntry(targetKey, out targetEntry))
                {
                    // Falls kein Eintrag vorhanden ist, führen Sie einen der folgenden Schritte aus:
                    // 1. Hierbei handelt es sich um einen EntityKey, der in der Entitätsgruppe, die während des Übernahmevorgangs bearbeitet wird, nicht dargestellt ist
                    // 2. Dies ist ein EntityKey, der einen der noch zu verarbeitenden hinzugefügten Einträge darstellt (daher nachschlagen)
                    EntityKey temporaryKey;
                    if (_temporaryKeyMap.TryGetValue(targetKey, out temporaryKey))
                    {
                        targetKey = temporaryKey;
                    }
                }
                return targetKey;
            }
        }
    
        // Vom RelationshipSet wird eine Liste aller Beziehungen von einer
        // Anfangsgruppe von Entitäten erstellt
        private sealed class RelationshipSet : IEnumerable<RelationshipWrapper>
        {
            private readonly HashSet<RelationshipWrapper> _relationships;
            private readonly ObjectContext _context;
    
            public RelationshipSet(ObjectContext context, IEnumerable<object> allEntities)
            {
                _context = context;
                _relationships = new HashSet<RelationshipWrapper>();
                foreach (object entity in allEntities)
                {
                    ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
                    foreach (IRelatedEnd relatedEnd in entry.RelationshipManager.GetAllRelatedEnds())
                    {
                        if (!((AssociationType)relatedEnd.RelationshipSet.ElementType).IsForeignKey)
                        {
                            foreach (object targetEntity in relatedEnd)
                            {
                                Add(relatedEnd, entity, targetEntity, EntityState.Unchanged);
                            }
                        }
                    }
                }
            }
    
            // Fügt einen Indexeintrag auf Grundlage von IRelatedEnd hinzu.
            public void Add(IRelatedEnd relatedEnd, object sourceEntity, object targetEntity, EntityState state)
            {
                RelationshipWrapper wrapper = new RelationshipWrapper(
                                    (AssociationSet)relatedEnd.RelationshipSet,
                                    relatedEnd.SourceRoleName,
                                    sourceEntity,
                                    relatedEnd.TargetRoleName,
                                    targetEntity,
                                    state);
                if (!_relationships.Contains(wrapper))
                {
                    _relationships.Add(wrapper);
                }
            }
    
            // Entfernt einen Eintrag aus dem Index auf Basis eines beziehungsbezogenen ObjectStateEntry
            public void Remove(ObjectStateEntry relationshipEntry)
            {
                Debug.Assert(relationshipEntry.IsRelationship);
                AssociationSet associationSet = (AssociationSet)relationshipEntry.EntitySet;
                DbDataRecord values = relationshipEntry.State == EntityState.Deleted ? relationshipEntry.OriginalValues : relationshipEntry.CurrentValues;
                int fromOridinal = values.GetOrdinal(associationSet.ElementType.AssociationEndMembers[0].Name);
                object fromEntity = _context.ObjectStateManager.GetObjectStateEntry((EntityKey)values.GetValue(fromOridinal)).Entity;
                int toOridinal = values.GetOrdinal(associationSet.ElementType.AssociationEndMembers[1].Name);
                object toEntity = _context.ObjectStateManager.GetObjectStateEntry((EntityKey)values.GetValue(toOridinal)).Entity;
    
                if (fromEntity != null && toEntity != null)
                {
                    RelationshipWrapper wrapper = new RelationshipWrapper(
                        associationSet,
                        associationSet.ElementType.AssociationEndMembers[0].Name,
                        fromEntity,
                        associationSet.ElementType.AssociationEndMembers[1].Name,
                        toEntity,
                        EntityState.Unchanged);
    
                    _relationships.Remove(wrapper);
                }
            }
    
            #region IEnumerable<RelationshipWrapper>
    
            public IEnumerator<RelationshipWrapper> GetEnumerator()
            {
                return _relationships.GetEnumerator();
            }
    
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return _relationships.GetEnumerator();
            }
    
            #endregion
        }
    
        // Ein RelationshipWrapper dient zur Identifizierung einer Beziehung zwischen zwei Entitäten
        // Die Beziehung wird durch den AssociationSet und die Reihenfolge der Entitäten auf Basis der
        // Rollen, die von ihnen übernommen werden, gekennzeichnet (über AssociationEndMember)
        private sealed class RelationshipWrapper : IEquatable<RelationshipWrapper>
        {
            internal readonly AssociationSet AssociationSet;
            internal readonly object End0;
            internal readonly object End1;
            internal readonly EntityState State;
    
            internal RelationshipWrapper(AssociationSet extent,
                                         string role0, object end0,
                                         string role1, object end1,
                                         EntityState state)
            {
                Debug.Assert(null != extent, "null AssociationSet");
                Debug.Assert(null != (object)end0, "null end0");
                Debug.Assert(null != (object)end1, "null end1");
    
                AssociationSet = extent;
                Debug.Assert(extent.ElementType.AssociationEndMembers.Count == 2, "Nur zwei Enden werden unterstützt");
    
                State = state;
    
                if (extent.ElementType.AssociationEndMembers[0].Name == role0)
                {
                    Debug.Assert(extent.ElementType.AssociationEndMembers[1].Name == role1, "a)Unterschied in roleAndKey1-Name");
                    End0 = end0;
                    End1 = end1;
                }
                else
                {
                    Debug.Assert(extent.ElementType.AssociationEndMembers[0].Name == role1, "b)Unterschied in roleAndKey1-Name");
                    Debug.Assert(extent.ElementType.AssociationEndMembers[1].Name == role0, "b)Unterschied in roleAndKey0-Name");
                    End0 = end1;
                    End1 = end0;
                }
            }
    
            internal ReadOnlyMetadataCollection<AssociationEndMember> AssociationEndMembers
            {
                get { return this.AssociationSet.ElementType.AssociationEndMembers; }
            }
    
            public override int GetHashCode()
            {
                return this.AssociationSet.Name.GetHashCode() ^ (this.End0.GetHashCode() + this.End1.GetHashCode());
            }
    
            public override bool Equals(object obj)
            {
                return Equals(obj as RelationshipWrapper);
            }
    
            public bool Equals(RelationshipWrapper wrapper)
            {
                return (Object.ReferenceEquals(this, wrapper) ||
                        ((null != wrapper) &&
                         Object.ReferenceEquals(this.AssociationSet, wrapper.AssociationSet) &&
                         Object.ReferenceEquals(this.End0, wrapper.End0) &&
                         Object.ReferenceEquals(this.End1, wrapper.End1)));
            }
        }
    }
}
